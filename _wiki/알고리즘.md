---
layout: wiki 
title: 알고리즘
---

<!-- TOC -->

- [제네릭 프로그래밍](#제네릭-프로그래밍)
- [크리스마스 강연](#크리스마스-강연)
- [P-NP](#p-np)
    - [Traveling Sales Person](#traveling-sales-person)
- [Big O](#big-o)
- [그래프](#그래프)
    - [한붓그리기](#한붓그리기)
- [Dynamic Programming](#dynamic-programming)
    - [탐욕<sup>Greedy</sup> 알고리즘](#탐욕greedy-알고리즘)
    - [Viterbi algorithm](#viterbi-algorithm)
- [String Manipulation](#string-manipulation)
    - [Aho Corasick](#aho-corasick)
- [무작위성](#무작위성)
- [귀납, 연역](#귀납-연역)
- [프로그래머, 수학으로 생각하라](#프로그래머-수학으로-생각하라)

<!-- /TOC -->

# 제네릭 프로그래밍
제네릭 프로그래밍이란 대부분의 일반적인 설정에서 효율 저하 없이 작동할 수 있도록 알고리즘과 자료구조를 설계하는 데 초점을 맞춘 프로그래밍에 대한 접근법이다. (알고리즘 산책, 2015)

# 크리스마스 강연
2008년, 나는 1826년 마이클 패러데이가 첫 연사로 나선 왕립 연구소 크리스마스 강연(Royal Institution Christmas Lectures)의 180번째 연사로 선발되는 행운을 누렸다. 2008년 당시 나의 강연은 컴퓨터과학이란 주제로 진행된 최초의 강연이었다. 강연을 준비하며 컴퓨터과학을 일반 대중에게 설명할 방법을 고심하느라 많은 시간을 쏟았지만, 활용할 자료가 거의 없고 이런 필요를 다루는 대중 서적 또한 거의 전무하다는 사실을 깨달았다. 따라서 금번 맥코믹의 새 책 출간은 내겐 더욱 환영할 만한 일이다. (미래를 바꾼 아홉 가지 알고리즘, 2011)

크리스 비숍이 추천사에서 언급한 [2008년 강연 영상](http://www.rigb.org/christmas-lectures/watch/2008/hi-tech-trek)

# P-NP
- P: Polynomial Time 다항식 시간 동안 '답을 해결할 수<sup>can provide an answer</sup> 있는' 문제. **해결** 문제.
- NP: Non-deterministic Polynomial Time 다항식 시간 동안 '주어진 답이 맞는지 확인할 수<sup>can be verified</sup> 있는' 문제. **검산** 문제.

NP는 하나의 경우에 대해서 옳은지 그른지 보는 것이고, P는 해답이 되는 경우를 찾을 때 까지 모든 경우에 대해 옳고 그름을 따지는 것. P-NP 문제의 가장 중요한 쟁점은 수학적 귀납법으로 경우의 수를 P의 영역으로 넣을 수 있는지의 여부를 묻는 것으로 볼 수 있다. 대표적인 예로, 정렬 문제의 경우 경우의 수가 <img src="http://chart.apis.google.com/chart?cht=tx&chl=n!">이지만, 이미 수학적 귀납법으로 <img src="http://chart.apis.google.com/chart?cht=tx&chl=O(n^2)">, 나아가 <img src="http://chart.apis.google.com/chart?cht=tx&chl=O(n\log{n})">으로 수렴된 바 있다. [source](https://namu.wiki/w/P-NP%20%EB%AC%B8%EC%A0%9C)

A **polynomial** is a linear combination of terms that look like `Constant * x^k`. On the opposite, exponential means something like `k^x`, where in both case `k` is a constant and `x` is a variable. [source](https://stackoverflow.com/a/4317444/3513266)

## Traveling Sales Person
[외판원(TSP) 문제](https://ko.wikipedia.org/wiki/%EC%99%B8%ED%8C%90%EC%9B%90_%EB%AC%B8%EC%A0%9C)는 대표적인 NP-Hard 문제다. 팩토리얼로 풀어야 하며 최적화 알고리즘이 없다.
![](http://mathonweb.com/entrtain/tsp/northam.gif)[source](http://mathonweb.com/entrtain/tsp/t_tsp.htm)

구글의 Google Trips 출시 소식에 [그래프 알고리즘을 소개](https://research.googleblog.com/2016/09/the-280-year-old-algorithm-inside.html)하는데, 여기서 TSP 문제도 함께 언급한다.

# Big O
Big-O 표기법은 다음 수식으로 표현될 수 있다.
```
O(f(n)) = s + C * f(n) + t
```
s는 작업 준비 시간이고, C는 비례 상수, t는 작업 정리 시간이다. 어떤 알고리즘에는 s, C, t들이 굉장히 큰 값일 수 있는데, 그런 경우 `s+t`가 `C*f(n)`을 압도할 수 있다. (전문가를 위한 C++, 2011)

# 그래프
다익스트라 알고리즘은 벨먼-포드 알고리즘과 동일한 작업을 수행하고 실행속도도 더 빠르다. 하지만 다익스트라 알고리즘은 가중치가 음수인 경우는 처리할 수 없으므로, 이런 경우에는 [벨먼-포드 알고리즘](https://ko.wikipedia.org/wiki/%EB%B2%A8%EB%A8%BC-%ED%8F%AC%EB%93%9C_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)을 사용한다. (위키피디어)

## 한붓그리기
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/72/Labelled_Eulergraph.svg/440px-Labelled_Eulergraph.svg.png" width="30%">
오일러 트레일 <sup>Eulerian trail</sup> 또는 오일러 패스 <sup>Eulerian path</sup>는 "Every vertex of this graph has an even degree." 모든 정점들이 짝수의 차수를 가져야 한다. 1736년 쾨니히스베르크의 다리 문제를 풀기 위해 도입, 그래프 이론의 시초 (위키피디어)
<img src="https://upload.wikimedia.org/wikipedia/commons/5/5d/Konigsberg_bridges.png" width="30%">

# Dynamic Programming
"컴퓨터 과학이 여는 세계"에서는 다이나믹 프로그래밍을 본질적인 의미를 더 살려서 '기억하며 풀기'로 번역했다.

분할정복<sup>divide and conquer</sup>과 차이는 부분 문제를 최대한 많이 이용하도록 나눈 다음, 정답을 한 번만 계산하고 저장해둔 뒤 다시 한 번 이 부분 문제를 이용할 때에는 저장해둔 정답을 바로 산출하여 이용

- 피보나치 수열
- Coin Change Problem<sup>동전 교환 문제</sup>: Greedy와 대조적으로 가장 작은 금액에 대해 최적의 솔루션을 찾고 각 금액에 대해 최적의 솔루션을 찾는다.
- LCS 문제를 풀기 위해 동적 계획법을 사용하기도 한다.
  - 메모이제이션<sup>memoization</sup>은 컴퓨터 프로그램이 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술이다. 동적 계획법의 핵심이 되는 기술이다.

## 탐욕<sup>Greedy</sup> 알고리즘
[배낭 문제(Knapsack Problem)](https://ko.wikipedia.org/wiki/%EB%B0%B0%EB%82%AD_%EB%AC%B8%EC%A0%9C)는 조합 최적화의 대표적 문제다. 근사<sup>Approximation</sup> 알고리즘인 탐욕<sup>Greedy</sup> 알고리즘은 가장 무거운 물건을 먼저 고른다.

## Viterbi algorithm
[mini example](http://idiom.ucsd.edu/~rlevy/teaching/winter2009/ligncse256/lectures/hmm_viterbi_mini_example.pdf)를 구현했다. `\delta_3` 의 값이 A, B 모두 잘못되어 있으며, (5) 수식이 잘못 표기되어 있다. 

알고리즘을 Python으로 구현했을때, brute force 방식으로 전부 계산했을때 맥북 기준 30초가 넘어간다. DP를 적용해 `max_delta_tr`를 구하여 `\psi`를 위한 max 값을 기억하며 풀 경우 7초가 걸렸다.

성능 개선을 위해 동일한 알고리즘을 C++로 구현해봤는데, 65초로 훨씬 늦다. CPU 사용률은 100%를 넘지 못하며 이는 Python도 마찬가지다. 동일한 100%인데 일반적인 기대와 달리 심각한 성능 차이가 난다.

동일한 알고리즘을 Java로 구현하면 3초대에 실행된다. `time`값은 6.5초 정도가 출력된다.

```
6.46s user 1.17s system 167% cpu 4.561 total
```

Java는 별도 처리를 하지 않았음에도 불구하고 CPU 사용률이 180%를 넘어간다. CPU 코어를 고르게 활용하는 것으로 보이며 일부 null 처리를 하여 계산 횟수도 C++에 비해 조금 적긴 하나 이 부분이 중요한 것 같진 않다.

Java가 가장 빠르고 Python, C++ 순이다. 일반적으로 가장 빠를 것으로 예상되는 C++가 비교가 무색할 정도로 성능이 낮다. 멀티 쓰레딩으로 개선이 될 것으로 보이나 아쉽게도 시도 해보진 못했다.

| 언어 | 시간 | CPU | 연산 |
| --- | --- | --- | --- |
| Python 2 | 16s | 100% | 1,869,188 |
| Python 3 | 7s | 100% | 1,869,188 |
| C++ | 65s | 100% | 2,314,485 |
| Java | 3s | 180% | 2,095,600 |

Viterbi는 단순 행렬 연산의 반복이다. 논문과 달리 stack underflow를 방지하기 위해 log로 합산했으며, 0 일때도 이후 계산을 잇기 위해 라플라스 스무딩 처리를 했다.

C++에서 `std::map`을 `std::unordered_map`으로 바꾸는 것만으로 한 문장에 7.38s가 걸리던 것을 2.55s로 줄일 수 있었다. 34% 수준으로 줄었으므로, 위 결과는 22s가 될 것으로 예상된다. 물론 그래도 느리기 때문에 좀 더 최적화는 필요하다.

# String Manipulation
## Aho Corasick
아호 코라식 알고리즘은 finite set of strings의 요소를 찾는 일종의 사전-매칭 알고리즘으로, 동시에 모든 문자열을 찾는다.

문자열은 중복 순열<sup>Permutations with repetition</sup>이므로 <img src="http://chart.apis.google.com/chart?cht=tx&chl={k^n}" />가 가능하다. (*k* elements, length *n*) 모든 위치에 가능하므로 문장의 길이인 (256 - 패턴 길이 *n*) * 패턴의 갯수 1,000,000개를 분자로 하여 <img src="http://chart.apis.google.com/chart?cht=tx&chl={k^n}" /> 분모로 나누면 매칭 확률을 구할 수 있다. [C++구현에 버그가 있었고 직접 패치](https://github.com/cjgdev/aho_corasick/pull/12)했다.

첫 실행시 트라이<sup>tries</sup>를 메모리에 읽어들이는 시간이 다소 걸리지만 이후 문장 부터는 비교가 필요 없을 정도로 빠른 성능을 보여준다. 대부분의 문장이 1~2ms 이내에 처리된다.

# 무작위성
가상의 동전 던지기를 수백만 번 했을 때의 결과처럼 편향이 없고 패턴이 나타나지 않는 난수를 컴퓨터나 기계장치로 만들어내는 것은 극히 어렵다. (뉴욕타임스 수학, 2013, 1988년 기사) 도널드 커누스의 책 『The Art of Computer Programming』 에서도 random에 대해 여러 챕터를 할애한다.

# 귀납, 연역
- 귀납<sup>induction</sup>: you start with your own experience and then generalize a rule. 경험으로 규칙을 일반화한다. 실험 과학자 마이클 패러데이. 대표적인 귀납주의자 프랜시스 베이컨.
- 연역<sup>deduction</sup>: you start with a rule and then apply it to new situations. 규칙으로 상황에 적용한다.

수학적 귀납법<sup>mathematical induction</sup>과는 정의가 다르다.

# 프로그래머, 수학으로 생각하라
- 진법 <sup>Number Bases</sup>
- 논리 <sup>Logic</sup>
- 나머지 <sup>Modular</sup>
- 수학적 귀납법 <sup>Mathematical Induction</sup>
- 순열과 조합
- 재귀 <sup>Recursion</sup>
- 지수적 폭발 <sup>Exponential Explosion</sup>  
제곱의 힘은 매우 강력하다. 마찬가지로 이진 검색 <sup>Binary Search</sup>는 매우 유용하다.
- 계산할 수 없는 문제
- 머신러닝  
이 책은 오래전에 나온 책의 재발행판인데, 이 챕터는 최근 시류에 따른 구색맞추기로 보여 실망스럽다.